<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/vsl/transform/transformer.js | VSL API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-doc.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/vsl-lang/VSL" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vsl/parser</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/tokenizer.js~Tokenizer.html">Tokenizer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/vslparser.js~VSLParser.html">VSLParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/vsltokenizer.js~VSLTokenizer.html">VSLTokenizer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-highlight">highlight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-bound">bound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VSLScope">VSLScope</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VSLTokenType">VSLTokenType</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vsl/parser/nodes</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/assignmentStatement.js~AssignmentStatement.html">AssignmentStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/binaryExpression.js~BinaryExpression.html">BinaryExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/classStatement.js~ClassStatement.html">ClassStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/codeBlock.js~CodeBlock.html">CodeBlock</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/commandChain.js~CommandChain.html">CommandChain</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/expressionStatement.js~ExpressionStatement.html">ExpressionStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/functionArgument.js~FunctionArgument.html">FunctionArgument</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/functionStatement.js~FunctionStatement.html">FunctionStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/functionizedOperator.js~FunctionizedOperator.html">FunctionizedOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/identifier.js~Identifier.html">Identifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/internalMarker.js~InternalMarker.html">InternalMarker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/literal.js~Literal.html">Literal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/propertyExpression.js~PropertyExpression.html">PropertyExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/subscript.js~Subscript.html">Subscript</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/type.js~Type.html">Type</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/typedIdentifier.js~TypedIdentifier.html">TypedIdentifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/parser/nodes/unaryExpression.js~UnaryExpression.html">UnaryExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AssignmentType">AssignmentType</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vsl/transform</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/asttool.js~ASTTool.html">ASTTool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/transformError.js~TransformError.html">TransformError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/transformation.js~Transformation.html">Transformation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/transformer.js~Transformer.html">Transformer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/transverser.js~Transverser.html">Transverser</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vsl/transform/passes</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/passes/FoldBinaryIntegerExpression.js~FoldBinaryIntegerExpression.html">FoldBinaryIntegerExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/passes/FoldFiniteIntegerRange.js~FoldFiniteIntegerRange.html">FoldFiniteIntegerRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/passes/VerifyFunctionAccessScope.js~VerifyFunctionAccessScope.html">VerifyFunctionAccessScope</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vsl/transform/scope</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/scope/id.js~Id.html">Id</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/scope/type.js~Type.html">Type</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vsl/transform/transformers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/transformers/scopetransverser.js~ScopeTransverser.html">ScopeTransverser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vsl/transform/transformers/vsltransformer.js~VSLTransformer.html">VSLTransformer</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/vsl/transform/transformer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Transformation from &apos;./transformation&apos;;
import Transverser from &apos;./transverser&apos;;
import ASTTool from &apos;./asttool&apos;;
import Node from &apos;../parser/nodes/node&apos;;

/**
 * Takes an AST and transforms it according to a series of transformations
 * 
 * This is a generic class, reference VSLTransfomer for a VSL-specific
 * implementation
 * 
 * ### Overview
 * This takes a series of &quot;passes&quot; which are applied to the AST, each &quot;pass&quot;
 *  would return a new AST node which would be replaced (if specified as so).
 * This is now excluded and further matching AST nodes would be applied
 * 
 * ### Usage
 * 
 * A `Transformer` can be subclassed (see {@link VSLTransformer}) with a no-args
 * providing this class with the applicable transformers. This class can also
 * be directly constructed with the applicable constructors with no difference.
 * A subclass of `Transformer` should not offer any significant interface not
 * specified by `Transformer` as internal structure might rapidly change.
 * 
 * Note: If you&apos;re in the REPL and want to just load everything. Just run:
 * 
 *     var VSLParser = require(&apos;./lib/vsl/parser/vslparser.js&apos;);
 *     var p = new VSLParser(); var ast = p.feed(&quot;1 + 1&quot;);
 *     var VSLTransformer = require(&apos;./lib/vsl/transform/vsltransformer&apos;);
 *     var t = new VSLTransformer();
 * 
 * Additionally, it is reccomended to use `Transformer#queue` to initially load
 * the AST.
 * 
 * ### Details
 * In practice, each AST Node is treated like a `Node**`, when a node is swapped
 * the other transformers will mutate it if applicable. This prevents infinite 
 * recursion at the end, the node will be requeued for processing, it&apos;s children
 * will be in turn verified for applicable transformations. This means a node should not rely on transformation order for any reason,
 * transformations may be parallelized and therefore should also not have any
 * side-effects and be thread safe, concurrency may or may not be implemented in
 * any specific way.
 */
export default class Transformer extends Transverser {
    
    /**
     * Creates a new Transformer with the given passes
     * @param {Transformation[]} passes - The given passes to setup
     */
    constructor(passes: Transformation[]) {
        super();
        
        /** @private */
        this.passes = passes;
        
        /** @private */
        this.time = null;
        
        /** @private */
        this.nodeQueue = [];
    }
    
    /**
     * Queues an AST to be parsed, calls `transform(ast:)` and automatically
     * handles transformation distribution. Therefore, this is the reccomended
     * way to automatically setup and queue the inital AST nodes.
     * 
     * It is reccomended to buffer expressions with `queue(ast:)` and use the transform
     * status to determine whether a fork of Transformers should be utilized or 
     * to simply continuing to pipe further AST statements into queue. This operation
     * may or may not be syncronous.
     * 
     * Avoid directly calling from a {@link Transformation}
     * 
     * Return value can be extracted by specifying an `.oncompletion` handler.
     * 
     * @param {any} ast - An AST as outputted by a `Parser`
     */
     queue(ast: any) {
         super.queue(ast);
     }
     
     /** @override */
     receivedNode(parent: Node | Node[], name: string) {
         this.appendNodeQueue(parent, name)
     }
     
     /**
      * Adds item to node queue
      * @private
      */
    appendNodeQueue(parent: Node | Node[], name: string) {
        this.nodeQueue.push([ parent[name], parent, name ]);
        this.didUpdateQueue()
    }
     
     /**
      * Handles the queue items
      * @private
      */
    didUpdateQueue() {
        var value, node, parent, item;
        while (value = this.nodeQueue.shift()) {
            [node, parent, item] = value;
            let result = this.transform(node, parent, item);
        }
    }
    
    /**
     * Transform the AST according to the setup transformer. This is recursively
     * called and should never be called from within a transformer
     * 
     * @param {Node} ast - An AST as outputted by a `Parser`
     * @param {Node|Node[]} parent - The parent node of the given ast
     * @param {any} name - The reference to the child relative to the parent.
     * @param {Transformation[]} [passes=this.passes] - Do not specify. Only for internal use
     * @return A transformed AST with the passes applied
     * 
     * @example
     * var AST = new VSLParser().feed(new VSLTokenizer().tokenize(input));
     * var final = new VSLTransformer(VSLTransformer.default).transform(AST);
     */
    transform(ast: any, parent: parent, name: any, passes: Transformation[] = this.passes) {
        
        let t = process.hrtime();
        
        for (let i = 0; i &lt; passes.length; i++) {
            let result = this.transform_once(
                ast,
                parent,
                name,
                passes[i]
            );
            
            if (result === false) {
                // Requeue with remaining transformations. Excluding current
                let queuedTransforms = passes.slice(i + 1);
                if (queuedTransforms.length &gt; 0)
                    this.transform(parent[name], parent, name, queuedTransforms);
                break;
            }
        }
        
    }
    
    /**
     * Transforms with single transformer.
     * 
     * @return {bool} if node was mutated and should be requeued.
     * @private
     */
    transform_once(ast: Node, parent: Node | Node[], name: any, pass: Transformation) {
        // Create the tool for modification
        let astTool = new ASTTool(parent, name);
        
        // Setup the transformation
        let transformation = new pass();
        let type = transformation.type
        
        // Ensure ast is of the correct type
        // otherwise stop processing the node
        if (!(type === null || ast instanceof type))
            return false;
        
        // Call transformation
        transformation.modify(ast, astTool);
        
        // Get new node
        let result = parent[name];
        
        return ast === result;
    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
