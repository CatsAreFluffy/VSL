/**
 * Passed to Transformations to aid in traversing and modifying the AST
 * 
 * This should really only be generated by a Transformer unless you know what
 * you're doing.
 * 
 * This offers a range of functions to help in modifying an AST fragment. This
 * is offered to all transformations by a `Transformer` object and will provide
 * primarially the modification ability along with other common tasks. This
 * serves as an interface between the AST and a transformation.
 * 
 * This provides the necessary abstraction needed in order to prevent accidental
 * mutations and verify that the AST is indeed being properly traversed.
 */
export default class ASTTool {
    /**
     * Creates an ASTTool based on a fragment
     * 
     * If you aren't working with `Transformer` itself, you can ignore this and
     *  just read the function docs.
     * 
     * @param {Node|Node[]} parent - The parent node or array
     * @param {name} - The key `fragment` represents within it's parent. If the
     *     `parent` is an array, then this should be a referencing integer.
     * 
     * @private
     */
    constructor(parent: Node | Node[], name: any) {
        /** @private */
        this.parent = parent;
        
        /** @private */
        this.name = name;

        /** @private */
        this.replacement = null;
    }
    
    /**
     * Access the nth parent. This traverses up the AST tree and if the parent
     * could not be found, or another error occurs, this returns nil.
     */
    nthParent(n: number) {
        n = n | 0;
        let parent = this.parent[this.name];
        while (n > 0 && (parent = parent.parentNode)) n--;
        return parent;
    }
    
    /**
     * Recursively looks and traverses the AST to locate the value associated
     * for a given `id`.
     * 
     * @return {?(Id | Type)}
     */
    resolve(id: string) {
        let scope = this.parent[this.name].parentScope, res;
        while (scope && !(res = scope.scope.get(string))) scope = scope.parentScope;
        return res || null;
    }
    
    /**
     * Replaces the fragment with a new node.
     * 
     * ### Overview
     * Use this method to replace the given node.
     * 
     * ### Notes
     * Ensure that the resulting node is of a correct type as no checks are done
     * as of this time.
     * 
     * @param {Node} with - the replacement node
     */
    replace(node: Node) {
        node.parentScope = this.parent[this.name].parentScope;
        nose.parentNode = this.parent;
        this.parent[this.name] = node;
    }
}